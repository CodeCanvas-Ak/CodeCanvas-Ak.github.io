- 教授在这一节课并没有讲述太多的内容，因此博客整体篇幅较短

# Document Distance Problem（文档距离问题）

- 文档距离问题可应用于网络搜索、查找相似文档、检测重复项（维基百科镜像和Google等)，当然也可以用于学生间检测作业的抄袭情况。
- 在讲解问题前，我们先定义一下几个术语：
-  单词 = 字母数字字符序列
-  文档 = 单词序列（忽略空格、标点符号等）

- 根据出现的相同的单词来定义距离。我们可以将文档 D 视为向量： D[w] = 则为单词 W 的出现次数。如下图：
![image](https://github.com/user-attachments/assets/45dfe931-e424-4ee5-baea-638d5b77c494)

- 接下来，你可能会想，那我把俩文档中不为0的向量做点乘，然后根据最后相加的“得分”不就可以得到俩文档的距离么？不错的尝试！
![image](https://github.com/user-attachments/assets/b41fc689-f2c6-45c5-8b99-868490f7ec3d)

- 但是会存在一个问题，在文本相似度的应用中，文档可能具有不同的长度。如果只用点积来衡量相似度，长文档的向量往往会比短文档的向量大，导致它们的相似度被夸大。例如，两个本质上不相关的长文档可能因为它们的向量长度而得到较高的相似度评分。

- 我们可以除以向量的模来解决上述困扰
![image](https://github.com/user-attachments/assets/6faf81f6-5bb4-483e-af9e-325054bc6ddc)
- 结果：
- 1 表示两个向量的方向完全相同（即完全相似）。
- 0 表示两个向量互相垂直（即无相关性）。
- -1 表示两个向量的方向完全相反（即完全不相似）。

## 时间复杂度分析
- 1. 点积的计算
 点积是两个向量元素逐一相乘并求和的操作。假设向量 A 和 B 各有 n 个元素，那么点积的计算如下：
-                                A⋅B=A1​×B1​+A2​×B2​+⋯+An​×Bn
- 这种逐元素相乘的操作需要遍历两个向量的每个元素，因此点积的时间复杂度是：O(n)
- 2.向量模长的计算公式为：
![image](https://github.com/user-attachments/assets/4997ceb4-96a0-4514-8cd7-2910f70463c7)
这需要对向量中的每个元素求平方、求和，然后计算平方根。对于 n 维向量，这个操作的时间复杂度也是：O(n)
> [!NOTE]
> 平方根的计算可以看作是一个常数时间操作，因此不影响整体复杂度。
- 3.余弦相似度的完整计算：
![image](https://github.com/user-attachments/assets/dfa4903c-7314-4249-b071-daef4f1ba5f8)
- 这一公式包括两个部分：
 计算点积 A⋅B的时间复杂度为 O(n)。
 计算模长||A||与 ||B|| 的时间复杂度分别为 O(n)。
 由于所有的操作都只需要遍历向量一次，并且没有嵌套的操作，所以整个余弦相似度计算的总时间复杂度为：O(n)