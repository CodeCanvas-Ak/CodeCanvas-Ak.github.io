# 闲谈
Hi~ o(*￣▽￣*)ブ 好久没见大家，正好碰上开学，头两周陆续忙碌了起来，今天难得的在周末假期空闲了下来。碰巧近几天又发现了一门MIT的宝藏课程，也就是大名鼎鼎《算法导论》这门课程，更令我惊喜的是，这门课程所使用的编程语言也为Python，这令我喜出望外，想着可以边学习算法知识一边又能巩固自己的Python学习，故此在中途开了个新篇章，也希望大家能跟我一同领略算法的魅力。

# One-d imensional Peek Finding（一维峰值查找算法）
- 首先我们来了解何为峰值：在一个数组中，元素的 **峰值（peak）** 定义为该元素大于等于其相邻元素。（对于边界上的元素，只需要考虑其存在的相邻元素）
- 比如在下面的图片中，如果b ≥ a 且 b ≥ c ，则位置 2 为峰值。如果 i ≥ h，则位置 9 为峰值。
![image](https://github.com/user-attachments/assets/3235e783-f509-4507-a0ac-e86bd5cd456c)

- 那么我们如何该去实现这一过程呢？想必你心中已经有了一个最直接的答案：即为 **线性查找**
- 对的，最简单的算法是从数组的左边开始依次检查每一个元素，看它是否比两侧的邻居大。这种方法的时间复杂度为 O(n)，因此在最坏的情况下，我们需要检查所有的元素才能找到一个峰值。例如，当峰值位于数组的最后一个位置时，我们必须遍历整个数组。

- 大家也可能察觉到了，随着数据规模的增大，算法所耗费的时间也会直线上升，那么我们有没有更好的方法去改进呢？

## 二分法（分而治之）

![image](https://github.com/user-attachments/assets/014babab-fab7-4308-9c7c-be7faba9a154)
- 基本思想是，从数组的中间位置开始，比较中间元素与其相邻的左右两个元素。根据比较结果，我们可以确定搜索的方向：
  如果中间元素比左边邻居小，那么峰值一定存在于左半部分，因此我们递归搜索左半部分。
  如果中间元素比右边邻居小，那么峰值一定在右半部分，因此我们递归搜索右半部分。
  如果中间元素既不小于左邻居也不小于右邻居，那么中间元素就是一个峰值。
> [!NOTE]
> 为什么这个算法总能找到一个峰值？
    因为无论在数组中选择哪个位置，我们总能找到一个方向向着更大的值进行移动，最终会到达一个峰值的位置。
- 而在时间复杂度上，每次递归调用时，问题的规模从 n变为n/2，即每次减少一半的数据量。所以递归的最大深度就是数组长度 
n 被二分减小到 1 的次数，因此整个算法的复杂度就是T(n)=O(logn)。比上述快了一个数量级!

# Two-dimensional Peek Finding（二维峰值查找）
- 对于一个二维数组中的某个位置 (i,j)，其值是峰值的条件是：该位置的元素大于等于它的四个邻居（上、下、左、右）.

- 举一反三，对于二维的情况我们也可以类似着一维的情况依然可以使用“分而治之”策略来实现。
- 尝试一：
-  假设我们有一个m*n的矩阵，将矩阵的中间列选为 j=m/2（即中间列）在第 j 列上查找一个“1D峰值”，即某行 i使得该位置上的元素 a[i][j] 大于等于它在该列中的上下邻居。之后，基于这个1D峰值的点 (i,j)，在第 i行上继续查找横向的1D峰值（左右方向）。
![image](https://github.com/user-attachments/assets/fbb943c6-838d-4df1-818b-ecec4ad1618d)
![image](https://github.com/user-attachments/assets/b1b04fc9-0300-4fdc-9d83-c2e65cab5d80)
-而在此种方法中，我们所找到的并不是二维数组的峰值，简单地从某一行开始查找1D峰值可能会导致找到一个局部峰值（如14），而不是全局的二维峰值。

- 尝试二：
     1. 选择中间列:
     ● 假设矩阵有m行和n列,我们首先选择矩阵的中间列(第n/2列),然后在该列中找到该列中的全局最大值位置,即第i行的最大值元素。
     2. 比较最大值与左右邻居:
     ● 取中间列上找到的最大值元素,比较它与左边和右边列的邻居:·如果该最大值大于其左邻居和右邻居,那么它就是一个峰值,直接返回。
     ● 如果该最大值小于左邻居,那么峰值一定存在于左半部分(因为更大的元素出现在左边),我们递归在左半部分继续查找。
     ● 如果该最大值小于右邻居,那么峰值一定存在于右半部分,递归在右半部分查找。

3. 递归缩小搜索范围:

· 每次递归时,问题的列数规模从n缩小为n/2,并在缩小的列中继续重复上述过程。
![image](https://github.com/user-attachments/assets/9ef15430-c743-42ac-a4e2-39c764d251c2)
- 下面我们来分析一下时间复杂度。
- 1. 每次递归时,我们在当前的中间列中找到一个全局最大值,这个过程的时间复杂度是O(m)。
  2. 我们需要进行O(log n)次递归,因为每次递归会将问题的列数从n减少到n/2。
- 最终,二维峰值查找的时间复杂度为:O(mlog n)如果矩阵是正方形的(即m=n),时间复杂度为O(nlog n)。


- 总结
通过峰值查找算法,了解了如何通过分而治之的方法在一维和二维数组中高效地找到峰值。相比于传统的线性查找,峰值查找算法以O(log n)或O(m log n)的时间复杂度显著提高了查找效率,特别适用于处理大规模数据集的场景。